{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Directive, Input, NgModule, TemplateRef, Component } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nlet TeleportService = /*#__PURE__*/(() => {\n  class TeleportService {\n    constructor() {\n      this.outlets = new BehaviorSubject('');\n      this.asObservable = this.outlets.asObservable();\n      this.ports = new Map();\n    }\n\n    outlet$(name) {\n      return this.asObservable.pipe(filter(current => current === name), map(name => this.ports.get(name)));\n    }\n\n    newOutlet(name) {\n      this.outlets.next(name);\n    }\n\n  }\n\n  TeleportService.ɵfac = function TeleportService_Factory(t) {\n    return new (t || TeleportService)();\n  };\n\n  TeleportService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TeleportService,\n    factory: TeleportService.ɵfac,\n    providedIn: 'root'\n  });\n  return TeleportService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TeleportOutletDirective = /*#__PURE__*/(() => {\n  class TeleportOutletDirective {\n    constructor(vcr, service) {\n      this.vcr = vcr;\n      this.service = service;\n    }\n\n    ngOnChanges(changes) {\n      // The `teleportOutlet` might be `null|undefined`, but we don't want nullable values to be used\n      // as keys for the `ports` map.\n      if (changes.teleportOutlet && typeof this.teleportOutlet === 'string') {\n        this.service.ports.set(this.teleportOutlet, this.vcr);\n        this.service.newOutlet(this.teleportOutlet);\n      }\n    }\n\n    ngOnDestroy() {\n      this.service.ports.delete(this.teleportOutlet);\n    }\n\n  }\n\n  TeleportOutletDirective.ɵfac = function TeleportOutletDirective_Factory(t) {\n    return new (t || TeleportOutletDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(TeleportService));\n  };\n\n  TeleportOutletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TeleportOutletDirective,\n    selectors: [[\"\", \"teleportOutlet\", \"\"]],\n    inputs: {\n      teleportOutlet: \"teleportOutlet\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TeleportOutletDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TeleportDirective = /*#__PURE__*/(() => {\n  class TeleportDirective {\n    constructor(tpl, service) {\n      this.tpl = tpl;\n      this.service = service;\n      this.subscription = null;\n    }\n\n    ngOnChanges(changes) {\n      if (changes.teleportTo && typeof this.teleportTo === 'string') {\n        this.dispose();\n        this.subscription = this.service.outlet$(this.teleportTo).subscribe(outlet => {\n          if (outlet) {\n            this.viewRef = outlet.createEmbeddedView(this.tpl);\n          }\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this.dispose();\n    }\n\n    dispose() {\n      var _a, _b;\n\n      (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n      this.subscription = null;\n      (_b = this.viewRef) === null || _b === void 0 ? void 0 : _b.destroy();\n    }\n\n  }\n\n  TeleportDirective.ɵfac = function TeleportDirective_Factory(t) {\n    return new (t || TeleportDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(TeleportService));\n  };\n\n  TeleportDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TeleportDirective,\n    selectors: [[\"\", \"teleportTo\", \"\"]],\n    inputs: {\n      teleportTo: \"teleportTo\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TeleportDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet TeleportModule = /*#__PURE__*/(() => {\n  class TeleportModule {}\n\n  TeleportModule.ɵfac = function TeleportModule_Factory(t) {\n    return new (t || TeleportModule)();\n  };\n\n  TeleportModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TeleportModule\n  });\n  TeleportModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TeleportModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction isTemplateRef(value) {\n  return value instanceof TemplateRef;\n}\n\nfunction isComponent(value) {\n  return typeof value === 'function';\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nlet DynamicViewComponent = /*#__PURE__*/(() => {\n  class DynamicViewComponent {}\n\n  DynamicViewComponent.ɵfac = function DynamicViewComponent_Factory(t) {\n    return new (t || DynamicViewComponent)();\n  };\n\n  DynamicViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DynamicViewComponent,\n    selectors: [[\"dynamic-view\"]],\n    inputs: {\n      content: \"content\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"innerHTML\"]],\n    template: function DynamicViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"innerHTML\", ctx.content, i0.ɵɵsanitizeHtml);\n      }\n    },\n    encapsulation: 2\n  });\n  return DynamicViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass TplRef {\n  constructor(args) {\n    this.args = args;\n    this.wrapper = null;\n\n    if (this.args.vcr) {\n      this.viewRef = this.args.vcr.createEmbeddedView(this.args.tpl, this.args.context || {});\n      this.viewRef.detectChanges();\n    } else {\n      this.viewRef = this.args.tpl.createEmbeddedView(this.args.context || {});\n      this.viewRef.detectChanges();\n      this.args.appRef.attachView(this.viewRef);\n    }\n  }\n\n  detectChanges() {\n    this.viewRef.detectChanges();\n  }\n\n  getElement() {\n    const rootNodes = this.viewRef.rootNodes;\n\n    if (rootNodes.length === 1 && rootNodes[0] === Node.ELEMENT_NODE) {\n      this.element = rootNodes[0];\n    } else {\n      this.element = document.createElement('div');\n      this.element.append(...rootNodes);\n    }\n\n    return this.element;\n  }\n\n  destroy() {\n    var _a;\n\n    if (this.viewRef.rootNodes[0] !== 1) {\n      (_a = this.element) === null || _a === void 0 ? void 0 : _a.parentNode.removeChild(this.element);\n      this.element = null;\n    }\n\n    if (!this.args.vcr) {\n      this.args.appRef.detachView(this.viewRef);\n    }\n\n    this.viewRef.destroy();\n    this.viewRef = null;\n  }\n\n}\n\nclass StringRef {\n  constructor(value) {\n    this.value = value;\n  }\n\n  getElement() {\n    return this.value;\n  }\n\n  detectChanges() {}\n\n  destroy() {}\n\n}\n\nclass CompRef {\n  constructor(options) {\n    this.options = options;\n\n    if (options.vcr) {\n      this.compRef = options.vcr.createComponent(options.component, {\n        index: options.vcr.length,\n        injector: options.injector || options.vcr.injector\n      });\n    } else {\n      const factory = options.resolver.resolveComponentFactory(options.component);\n      this.compRef = factory.create(options.injector);\n      options.appRef.attachView(this.compRef.hostView);\n    }\n  }\n\n  get ref() {\n    return this.compRef;\n  }\n\n  setInput(input, value) {\n    this.compRef.instance[input] = value;\n    return this;\n  }\n\n  setInputs(inputs) {\n    Object.keys(inputs).forEach(input => {\n      this.compRef.instance[input] = inputs[input];\n    });\n    return this;\n  }\n\n  detectChanges() {\n    this.compRef.hostView.detectChanges();\n    return this;\n  }\n\n  appendTo(container) {\n    container.appendChild(this.getElement());\n    return this;\n  }\n\n  removeFrom(container) {\n    container.removeChild(this.getElement());\n    return this;\n  }\n\n  getRawContent() {\n    return this.getElement().outerHTML;\n  }\n\n  getElement() {\n    return this.compRef.location.nativeElement;\n  }\n\n  destroy() {\n    this.compRef.destroy();\n    !this.options.vcr && this.options.appRef.detachView(this.compRef.hostView);\n    this.compRef = null;\n  }\n\n}\n\nlet ViewService = /*#__PURE__*/(() => {\n  class ViewService {\n    constructor(resolver, injector, appRef) {\n      this.resolver = resolver;\n      this.injector = injector;\n      this.appRef = appRef;\n    }\n\n    createComponent(component, options = {}) {\n      return new CompRef({\n        component,\n        vcr: options.vcr,\n        injector: options.injector || this.injector,\n        appRef: this.appRef,\n        resolver: this.resolver\n      });\n    }\n\n    createTemplate(tpl, options = {}) {\n      return new TplRef({\n        vcr: options.vcr,\n        appRef: this.appRef,\n        tpl,\n        context: options.context\n      });\n    }\n\n    createView(content, viewOptions = {}) {\n      if (isTemplateRef(content)) {\n        return this.createTemplate(content, viewOptions);\n      } else if (isComponent(content)) {\n        return this.createComponent(content, viewOptions);\n      } else if (isString(content)) {\n        return new StringRef(content);\n      } else {\n        throw 'Type of content is not supported';\n      }\n    }\n\n  }\n\n  ViewService.ɵfac = function ViewService_Factory(t) {\n    return new (t || ViewService)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.ApplicationRef));\n  };\n\n  ViewService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ViewService,\n    factory: ViewService.ɵfac,\n    providedIn: 'root'\n  });\n  return ViewService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicViewDirective = /*#__PURE__*/(() => {\n  class DynamicViewDirective {\n    constructor(defaultTpl, vcr, viewService) {\n      this.defaultTpl = defaultTpl;\n      this.vcr = vcr;\n      this.viewService = viewService;\n    }\n\n    ngOnInit() {\n      this.resolveContentType();\n    }\n\n    ngOnChanges(changes) {\n      if (changes.view && !changes.view.isFirstChange()) {\n        this.resolveContentType();\n      }\n    }\n\n    resolveContentType() {\n      var _a, _b;\n\n      (_a = this.viewRef) === null || _a === void 0 ? void 0 : _a.destroy();\n\n      if (isString(this.view)) {\n        this.viewRef = this.viewService.createComponent(DynamicViewComponent, {\n          vcr: this.vcr,\n          injector: this.injector\n        });\n        this.viewRef.setInput('content', this.view).detectChanges();\n      } else {\n        this.viewRef = this.viewService.createView(this.view || this.defaultTpl, {\n          vcr: this.vcr,\n          injector: (_b = this.injector) !== null && _b !== void 0 ? _b : this.vcr.injector,\n          context: this.context\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      var _a;\n\n      (_a = this.viewRef) === null || _a === void 0 ? void 0 : _a.destroy();\n    }\n\n  }\n\n  DynamicViewDirective.ɵfac = function DynamicViewDirective_Factory(t) {\n    return new (t || DynamicViewDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(ViewService));\n  };\n\n  DynamicViewDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DynamicViewDirective,\n    selectors: [[\"\", \"dynamicView\", \"\"]],\n    inputs: {\n      view: [\"dynamicView\", \"view\"],\n      injector: [\"dynamicViewInjector\", \"injector\"],\n      context: [\"dynamicViewContext\", \"context\"]\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return DynamicViewDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DynamicViewModule = /*#__PURE__*/(() => {\n  class DynamicViewModule {}\n\n  DynamicViewModule.ɵfac = function DynamicViewModule_Factory(t) {\n    return new (t || DynamicViewModule)();\n  };\n\n  DynamicViewModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DynamicViewModule\n  });\n  DynamicViewModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return DynamicViewModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of overview\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CompRef, DynamicViewDirective, DynamicViewModule, StringRef, TeleportDirective, TeleportModule, TeleportOutletDirective, TplRef, ViewService, isComponent, isString, isTemplateRef }; //# sourceMappingURL=ngneat-overview.mjs.map","map":null,"metadata":{},"sourceType":"module"}